<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>operating_system on kurisaW</title><link>https://kurisaw.github.io/categories/operating_system/</link><description>Recent content in operating_system on kurisaW</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 10 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://kurisaw.github.io/categories/operating_system/index.xml" rel="self" type="application/rss+xml"/><item><title>信号量及PV操作详解</title><link>https://kurisaw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%8F%8Apv%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/</link><pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate><guid>https://kurisaw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%8F%8Apv%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/</guid><description>&lt;img src="https://kurisaw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%8F%8Apv%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/cover.jpg" alt="Featured image of post 信号量及PV操作详解" />&lt;h2 id="信号量">信号量
&lt;/h2>&lt;blockquote>
&lt;ul>
&lt;li>&lt;!-- raw HTML omitted -->一个特殊变量&lt;/li>
&lt;li>&lt;!-- raw HTML omitted -->用于进程间传递信息的一个整数值&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>定义如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">struct semaphore
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int count;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> quenue Type quenue;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;ul>
&lt;li>&lt;!-- raw HTML omitted -->信号量说明:semaphore s;&lt;/li>
&lt;li>&lt;!-- raw HTML omitted -->对信号量可以实施的操作：初始化、P和V（P、V分别是荷兰语的test（proberen）和increment（verhogen））&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="pv操作定义">P、V操作定义
&lt;/h2>&lt;p>&lt;!-- raw HTML omitted -->P(s)&lt;!-- raw HTML omitted -->&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> s.count --; //信号量值减一
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if(s.count&amp;lt;0)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 该进程状态置为阻塞态；
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 将该进程插入相应的等待队列s.quenue末尾；
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 重新调度
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>down&lt;/code>,&lt;code>semwait&lt;/code>:也代表P操作&lt;/p>
&lt;p>&lt;!-- raw HTML omitted -->V(s)&lt;!-- raw HTML omitted -->&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> s.ount++;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if(s.count&amp;lt;=0)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 唤醒相应等待队列s.queue中等待的一个进程；
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> 改变其状态为就绪态，并将其插入就绪队列；
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>up&lt;/code>,&lt;code>semsignal&lt;/code>:也代表V操作&lt;/p>
&lt;blockquote>
&lt;p>相关说明&lt;/p>
&lt;ul>
&lt;li>&lt;!-- raw HTML omitted -->P，V操作为原语操作&lt;/li>
&lt;li>&lt;!-- raw HTML omitted -->在信号量上定义了三个操作
&lt;!-- raw HTML omitted -->初始化（非负数）、P操作、V操作&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>&lt;!-- raw HTML omitted -->最初提出的是二元信号量（解决互斥）
之后，推广到一般信号量（多值）或技术信号量（解决同步）&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h2 id="用pv操作解决进程间互斥问题">用PV操作解决进程间互斥问题
&lt;/h2>&lt;blockquote>
&lt;ul>
&lt;li>&lt;!-- raw HTML omitted -->分析并发进程的关键活动，划定临界区&lt;/li>
&lt;li>&lt;!-- raw HTML omitted -->设置信号量mutux，初值为1&lt;/li>
&lt;li>&lt;!-- raw HTML omitted -->在临界区前实施P(mutux)&lt;/li>
&lt;li>&lt;!-- raw HTML omitted -->在临界区之后实施V(mutux)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>&lt;img src="https://img-blog.csdnimg.cn/9f7d7a26cf6a41048d7205423383fa64.png"
loading="lazy"
alt="图片演示"
>&lt;/p>
&lt;blockquote>
&lt;p>相关解释：&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>&lt;code>临界区&lt;/code> : 我们把并发进程中与共享变量有关的程序段称为临界区。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>信号量&lt;/code> : 信号量的值与相应资源的使用情况有关。当它的值大于0时，表示当前可用资源的数量；当它的值小于0时，其绝对值表示等待使用该资源的进程个数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>进程的互斥&lt;/code>:是指当有若干个进程都要使用某一共享资源时，任何时刻最多只允许一个进程去使用该资源，其他要使用它的进程必须等待，直到该资源的占用着释放了该资源。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>进程的同步&lt;/code>:是指在并发进程之间存在这一种制约关系，一个进程依赖另一个进程的消息，当一个进程没有得到另一个进程的消息时应等待，直到消息到达才被唤醒。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>pv操作又称wait,signal原语。&lt;/code>
主要是操作进程中对进程控制的信息量的加减控制。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;!-- raw HTML omitted -->&lt;code>注意：&lt;/code>在霍尔管程中,&lt;code>wait操作&lt;/code>和&lt;code>signal操作&lt;/code>用于被设计为两个可以中断的过程，而非&lt;code>原语。&lt;/code>
&lt;!-- raw HTML omitted -->在管程中，引入一种数据结构—条件变量（仅在管程中可以被访问）。
条件变量的两种操作：&lt;/p>
&lt;ul>
&lt;li>wait()操作&lt;!-- raw HTML omitted -->[阻塞调用进程]&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>signal()操作&lt;!-- raw HTML omitted -->[释放/唤醒在条件变量上阻塞的进程]&lt;!-- raw HTML omitted -->&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>wait用法：
wait(num),num是目标参数，wait的作用是使其（信息量）减一。
如果信息量&amp;gt;=0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。
signal用法：
signal(num),num是目标参数，signal的作用是使其（信息量）加一。
如果信息量&amp;gt;0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>本文资源来自&lt;a class="link" href="https://www.coursera.org/learn/os-pku" target="_blank" rel="noopener"
>Operating Systems&lt;/a>
参考：&lt;a class="link" href="https://blog.csdn.net/thebestway/article/details/105034840?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164992015416780255296134%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;amp;request_id=164992015416780255296134&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-105034840.142%5ev8%5epc_search_result_cache,157%5ev4%5econtrol&amp;amp;utm_term=wait%E5%92%8Csignal%E5%8E%9F%E8%AF%AD&amp;amp;spm=1018.2226.3001.4187" target="_blank" rel="noopener"
>操作系统P,V(wait,signal原语)操作讲解&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>进程上下文和线程上下文</title><link>https://kurisaw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87/</link><pubDate>Tue, 08 Mar 2022 00:00:00 +0000</pubDate><guid>https://kurisaw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87/</guid><description>&lt;img src="https://kurisaw.github.io/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87/cover.jpg" alt="Featured image of post 进程上下文和线程上下文" />&lt;h2 id="进程">进程
&lt;/h2>&lt;p>&lt;code>操作系统资源分配的基本单位&lt;/code>，也就是指计算机中已执行的程序。&lt;/p>
&lt;ul>
&lt;li>在面向进程设计的系统（如早期的UNIX，Linux 2.4及更早的版本）中，&lt;code>进程&lt;/code>是程序的基本执行实体；&lt;/li>
&lt;li>在面向线程设计的系统（如当代多数操作系统、Linux 2.6及更新的版本）中，进程本身不是基本执行单位，而是&lt;code>线程&lt;/code>的容器。&lt;/li>
&lt;li>程序本身只是指令、数据及其组织形式的描述，相当于一个名词，&lt;code>进程&lt;/code>才是程序（那些指令和数据）的真正&lt;code>执行实例&lt;/code>.&lt;/li>
&lt;/ul>
&lt;h2 id="进程上下文">进程上下文
&lt;/h2>&lt;p>&lt;code>进程上下文&lt;/code>就是表示&lt;code>进程信息&lt;/code>的一系列东西，包括各种变量、寄存器以及进程的运行的环境。这样，当进程被切换后，下次再切换回来继续执行，能够知道原来的状态。&lt;/p>
&lt;p>拿&lt;code>Linux进程&lt;/code>举例：
&amp;mdash;-进程的运行环境主要包括：&lt;/p>
&lt;blockquote>
&lt;p>1.进程空间中的代码和数据、各种数据结构、进程堆栈和共享内存区等。
2.环境变量：提供进程运行所需的环境信息。
3.系统数据：进程空间中的对进程进行管理和控制所需的信息，包括进程任务结构体以及内核堆栈等。
4.进程访问设备或者文件时的权限。
5.各种硬件寄存器。
6.地址转换信息。&lt;/p>
&lt;/blockquote>
&lt;p>由上可知，进程的运行环境是动态变化的，尤其是硬件寄存器的值以及进程控制信息是随着进程的运行而不断变化的。在Linux中把系统提供给进程的的处于动态变化的运行环境总和称为进程上下文。&lt;/p>
&lt;h2 id="线程">线程
&lt;/h2>&lt;p>&lt;code>操作系统能够进行运算调度的最小单位&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>大部分情况下，它被包含在进程之中，是进程中的实际运作单位。&lt;/li>
&lt;li>一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。&lt;/li>
&lt;li>线程是独立调度和分派的基本单位。
线程可以为操作系统内核调度的内核线程，如Win32线程；由用户进程自行调度的用户线程，如Linux平台的POSIX Thread；或者由内核与用户进程，如Windows 7的线程，进行混合调度。&lt;/li>
&lt;li>同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈（call stack），自己的寄存器环境（register context），自己的线程本地存储（thread-local storage）。&lt;/li>
&lt;/ul>
&lt;h2 id="线程上下文">线程上下文
&lt;/h2>&lt;p>进程的上下文的多数信息都与地址空间的描述有关。进程的上下文使用很多系统资源，而且会花费一些时间来从一个进程的上下文切换到另一个进程的上下文。&lt;code>同样的，线程也有上下文。&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>当线程被抢占时，就会发生线程之间的上下文切换。
如果线程属于相同的进程，它们共享相同的地址空间，因为线程包含在它们所属于的进程的地址空间内。这样，进程需要恢复的多数信息对于线程而言是不需要的。尽管进程和它的线程共享了很多内容，但最为重要的是其地址空间和资源，有些信息对于线程而言是本地且唯一的，而线程的其他方面包含在进程的各个段的内部。&lt;/p>
&lt;/blockquote>
&lt;p>线程上下文与进程上下文对比&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>上下文内容&lt;/th>
&lt;th>进程&lt;/th>
&lt;th>线程&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>指向可执行文件的指针&lt;/td>
&lt;td>×&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>栈&lt;/td>
&lt;td>×&lt;/td>
&lt;td>×&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>内存（数据段和堆）&lt;/td>
&lt;td>×&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>状态&lt;/td>
&lt;td>×&lt;/td>
&lt;td>×&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>优先级&lt;/td>
&lt;td>×&lt;/td>
&lt;td>×&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>程序IO的状态&lt;/td>
&lt;td>×&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>授予权限&lt;/td>
&lt;td>×&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>调度信息&lt;/td>
&lt;td>×&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>审计信息&lt;/td>
&lt;td>×&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>文件描述符&lt;/td>
&lt;td>×&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>文件读/写指针&lt;/td>
&lt;td>×&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>寄存器组&lt;/td>
&lt;td>×&lt;/td>
&lt;td>×&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item></channel></rss>