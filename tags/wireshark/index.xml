<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Wireshark on kurisaW</title><link>https://kurisaw.github.io/tags/wireshark/</link><description>Recent content in Wireshark on kurisaW</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 10 Apr 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://kurisaw.github.io/tags/wireshark/index.xml" rel="self" type="application/rss+xml"/><item><title>Wireshark网络抓包教程</title><link>https://kurisaw.github.io/p/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%ABwireshark%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B/</link><pubDate>Mon, 10 Apr 2023 00:00:00 +0000</pubDate><guid>https://kurisaw.github.io/p/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%ABwireshark%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B/</guid><description>&lt;img src="https://kurisaw.github.io/p/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%ABwireshark%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B/cover.jpg" alt="Featured image of post Wireshark网络抓包教程" />&lt;blockquote>
&lt;p>来源：&lt;a class="link" href="https://blog.csdn.net/HarveyH/article/details/113731485" target="_blank" rel="noopener"
>转自：WireShark 抓包使用教程&amp;ndash;详细&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="前言">前言
&lt;/h2>&lt;p>Wireshark是非常流行的网络封包分析软件，可以截取各种网络数据包，并显示数据包详细信息。常用于开发测试过程各种问题定位。本文主要内容包括：&lt;/p>
&lt;p>1、Wireshark软件下载和安装以及Wireshark主界面介绍。&lt;/p>
&lt;p>2、WireShark简单抓包示例。通过该例子学会怎么抓包以及如何简单查看分析数据包内容。&lt;/p>
&lt;p>3、Wireshark过滤器使用。通过过滤器可以筛选出想要分析的内容。包括按照协议过滤、端口和主机名过滤、数据包内容过滤。&lt;/p>
&lt;h2 id="wireshark软件安装">Wireshark软件安装
&lt;/h2>&lt;p>软件下载路径：&lt;a class="link" href="https://www.wireshark.org/" target="_blank" rel="noopener"
>wireshark官网&lt;/a>。按照系统版本选择下载，下载完成后，按照软件提示一路Next安装。&lt;/p>
&lt;p>如果你是Win10系统，安装完成后，选择抓包但是不显示网卡，下载win10pcap兼容性安装包。下载路径：&lt;a class="link" href="http://www.win10pcap.org/download/" target="_blank" rel="noopener"
>win10pcap兼容性安装包&lt;/a>&lt;/p>
&lt;h2 id="wireshark-开始抓包示例">&lt;strong>Wireshark 开始抓包示例&lt;/strong>
&lt;/h2>&lt;p>先介绍一个使用wireshark工具抓取ping命令操作的示例，让读者可以先上手操作感受一下抓包的具体过程。&lt;/p>
&lt;p>1、打开wireshark 2.6.5，主界面如下：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102042369.png"
loading="lazy"
alt="image-20230410204240214"
>&lt;/p>
&lt;p>2、选择菜单栏上Capture -&amp;gt; Option，勾选WLAN网卡（这里需要根据各自电脑网卡使用情况选择，简单的办法可以看使用的IP对应的网卡）。点击Start。启动抓包。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102043634.png"
loading="lazy"
alt="image-20230410204301558"
>&lt;/p>
&lt;p>3、wireshark启动后，wireshark处于抓包状态中。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102043120.png"
loading="lazy"
alt="image-20230410204330881"
>&lt;/p>
&lt;p>4、执行需要抓包的操作，如ping &lt;a class="link" href="https://www.baidu.com" target="_blank" rel="noopener"
>www.baidu.com&lt;/a>。&lt;/p>
&lt;p>5、操作完成后相关数据包就抓取到了。为避免其他无用的数据包影响分析，可以通过在过滤栏设置过滤条件进行数据包列表过滤，获取结果如下。说明：ip.addr == 119.75.217.26 and icmp 表示只显示ICPM协议且源主机IP或者目的主机IP为119.75.217.26的数据包。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102043973.png"
loading="lazy"
alt="image-20230410204349768"
>&lt;/p>
&lt;p>5、wireshark抓包完成，就这么简单。关于wireshark过滤条件和如何查看数据包中的详细内容在后面介绍。&lt;/p>
&lt;h2 id="wireshakr抓包界面">Wireshakr抓包界面
&lt;/h2>&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102044121.png"
loading="lazy"
alt="image-20230410204417023"
>&lt;/p>
&lt;p>说明：数据包列表区中不同的协议使用了不同的颜色区分。协议颜色标识定位在菜单栏View --&amp;gt; Coloring Rules。如下所示&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102044221.png"
loading="lazy"
alt="image-20230410204435065"
>&lt;/p>
&lt;p>&lt;strong>WireShark 主要分为这几个界面&lt;/strong>&lt;/p>
&lt;p>1. Display Filter(显示过滤器)， 用于设置过滤条件进行数据包列表过滤。菜单路径：Analyze --&amp;gt; Display Filters。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102045496.png"
loading="lazy"
alt="image-20230410204500320"
>&lt;/p>
&lt;p>2. Packet List Pane(数据包列表)， 显示捕获到的数据包，每个数据包包含编号，时间戳，源地址，目标地址，协议，长度，以及数据包信息。 不同协议的数据包使用了不同的颜色区分显示。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102045343.png"
loading="lazy"
alt="image-20230410204525166"
>&lt;/p>
&lt;p>3. Packet Details Pane(数据包详细信息), 在数据包列表中选择指定数据包，在数据包详细信息中会显示数据包的所有详细信息内容。数据包详细信息面板是最重要的，用来查看协议中的每一个字段。各行信息分别为&lt;/p>
&lt;p>（1）Frame: 物理层的数据帧概况&lt;/p>
&lt;p>（2）Ethernet II: 数据链路层以太网帧头部信息&lt;/p>
&lt;p>（3）Internet Protocol Version 4: 互联网层IP包头部信息&lt;/p>
&lt;p>（4）Transmission Control Protocol: 传输层T的数据段头部信息，此处是TCP&lt;/p>
&lt;p>（5）Hypertext Transfer Protocol: 应用层的信息，此处是HTTP协议&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102045382.png"
loading="lazy"
alt="image-20230410204540297"
>&lt;/p>
&lt;p>&lt;strong>TCP包的具体内容&lt;/strong>&lt;/p>
&lt;p>从下图可以看到wireshark捕获到的TCP包中的每个字段。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102045329.png"
loading="lazy"
alt="image-20230410204557194"
>&lt;/p>
&lt;p>4. Dissector Pane(数据包字节区)。&lt;/p>
&lt;h2 id="wireshark过滤器设置">Wireshark过滤器设置
&lt;/h2>&lt;p>初学者使用wireshark时，将会得到大量的冗余数据包列表，以至于很难找到自己自己抓取的数据包部分。wireshar工具中自带了两种类型的过滤器，学会使用这两种过滤器会帮助我们在大量的数据中迅速找到我们需要的信息。&lt;/p>
&lt;p>（1）抓包过滤器&lt;/p>
&lt;p>捕获过滤器的菜单栏路径为Capture --&amp;gt; Capture Filters。用于&lt;strong>在抓取数据包前设置。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102046204.png"
loading="lazy"
alt="image-20230410204620124"
>&lt;/p>
&lt;p>如何使用？可以在抓取数据包前设置如下。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102046995.png"
loading="lazy"
alt="image-20230410204653927"
>&lt;/p>
&lt;p>ip host 60.207.246.216 and icmp表示只捕获主机IP为60.207.246.216的ICMP数据包。获取结果如下：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102047470.png"
loading="lazy"
alt="image-20230410204717268"
>&lt;/p>
&lt;p>（2）显示过滤器&lt;/p>
&lt;p>显示过滤器是用于在抓取数据包后设置过滤条件进行过滤数据包。通常是在抓取数据包时设置条件相对宽泛，抓取的数据包内容较多时使用显示过滤器设置条件顾虑以方便分析。同样上述场景，在捕获时未设置捕获规则直接通过网卡进行抓取所有数据包，如下&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102047185.png"
loading="lazy"
alt="image-20230410204734985"
>&lt;/p>
&lt;p>执行ping &lt;a class="link" href="https://www.huawei.com" target="_blank" rel="noopener"
>www.huawei.com&lt;/a>获取的数据包列表如下&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102047584.png"
loading="lazy"
alt="image-20230410204753507"
>&lt;/p>
&lt;p>观察上述获取的数据包列表，含有大量的无效数据。这时可以通过设置显示器过滤条件进行提取分析信息。ip.addr == 211.162.2.183 and icmp。并进行过滤。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102048361.png"
loading="lazy"
alt="image-20230410204815301"
>&lt;/p>
&lt;p>上述介绍了抓包过滤器和显示过滤器的基本使用方法。**在组网不复杂或者流量不大情况下，使用显示器过滤器进行抓包后处理就可以满足我们使用。**下面介绍一下两者间的语法以及它们的区别。&lt;/p>
&lt;p>&lt;strong>wireshark过滤器表达式的规则&lt;/strong>&lt;/p>
&lt;p>1、抓包过滤器语法和实例&lt;/p>
&lt;p>抓包过滤器类型Type（host、net、port）、方向Dir（src、dst）、协议Proto（ether、ip、tcp、udp、http、icmp、ftp等）、逻辑运算符（&amp;amp;&amp;amp; 与、|| 或、！非）&lt;/p>
&lt;p>（1）协议过滤&lt;/p>
&lt;p>比较简单，直接在抓包过滤框中直接输入协议名即可。&lt;/p>
&lt;p>TCP，只显示TCP协议的数据包列表&lt;/p>
&lt;p>HTTP，只查看HTTP协议的数据包列表&lt;/p>
&lt;p>ICMP，只显示ICMP协议的数据包列表&lt;/p>
&lt;p>（2）IP过滤&lt;/p>
&lt;p>host 192.168.1.104&lt;/p>
&lt;p>src host 192.168.1.104&lt;/p>
&lt;p>dst host 192.168.1.104&lt;/p>
&lt;p>（3）端口过滤&lt;/p>
&lt;p>port 80&lt;/p>
&lt;p>src port 80&lt;/p>
&lt;p>dst port 80&lt;/p>
&lt;p>（4）逻辑运算符&amp;amp;&amp;amp; 与、|| 或、！非&lt;/p>
&lt;p>src host 192.168.1.104 &amp;amp;&amp;amp; dst port 80 抓取主机地址为192.168.1.80、目的端口为80的数据包&lt;/p>
&lt;p>host 192.168.1.104 || host 192.168.1.102 抓取主机为192.168.1.104或者192.168.1.102的数据包&lt;/p>
&lt;p>！broadcast 不抓取广播数据包&lt;/p>
&lt;p>2、显示过滤器语法和实例&lt;/p>
&lt;p>（1）比较操作符&lt;/p>
&lt;p>比较操作符有== 等于、！= 不等于、&amp;gt; 大于、&amp;lt; 小于、&amp;gt;= 大于等于、&amp;lt;=小于等于。&lt;/p>
&lt;p>（2）协议过滤&lt;/p>
&lt;p>比较简单，直接在Filter框中直接输入协议名即可。&lt;strong>注意：协议名称需要输入小写。&lt;/strong>&lt;/p>
&lt;p>tcp，只显示TCP协议的数据包列表&lt;/p>
&lt;p>http，只查看HTTP协议的数据包列表&lt;/p>
&lt;p>icmp，只显示ICMP协议的数据包列表&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102048252.png"
loading="lazy"
alt="image-20230410204852057"
>&lt;/p>
&lt;p>（3） ip过滤&lt;/p>
&lt;p>ip.src ==192.168.1.104 显示源地址为192.168.1.104的数据包列表&lt;/p>
&lt;p>ip.dst==192.168.1.104, 显示目标地址为192.168.1.104的数据包列表&lt;/p>
&lt;p>ip.addr == 192.168.1.104 显示源IP地址或目标IP地址为192.168.1.104的数据包列表&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102049772.png"
loading="lazy"
alt="image-20230410204937591"
>&lt;/p>
&lt;p>（4）端口过滤&lt;/p>
&lt;p>tcp.port ==80, 显示源主机或者目的主机端口为80的数据包列表。&lt;/p>
&lt;p>tcp.srcport == 80, 只显示TCP协议的源主机端口为80的数据包列表。&lt;/p>
&lt;p>tcp.dstport == 80，只显示TCP协议的目的主机端口为80的数据包列表。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102049752.png"
loading="lazy"
alt="image-20230410204953546"
>&lt;/p>
&lt;p>（5） Http模式过滤&lt;/p>
&lt;p>http.request.method==&amp;ldquo;GET&amp;rdquo;, 只显示HTTP GET方法的。&lt;/p>
&lt;p>（6）逻辑运算符为 and/or/not&lt;/p>
&lt;p>过滤多个条件组合时，使用and/or。比如获取IP地址为192.168.1.104的ICMP数据包表达式为ip.addr == 192.168.1.104 and icmp&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102050123.png"
loading="lazy"
alt="image-20230410205019907"
>&lt;/p>
&lt;p>（7）按照数据包内容过滤。假设我要以IMCP层中的内容进行过滤，可以单击选中界面中的码流，在下方进行选中数据。如下&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102050553.png"
loading="lazy"
alt="image-20230410205039366"
>&lt;/p>
&lt;p>右键单击选中后出现如下界面&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102050685.png"
loading="lazy"
alt="image-20230410205054595"
>&lt;/p>
&lt;p>选中Select后在过滤器中显示如下&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102051573.png"
loading="lazy"
alt="image-20230410205109402"
>&lt;/p>
&lt;p>后面条件表达式就需要自己填写。如下我想过滤出data数据包中包含&amp;quot;abcd&amp;quot;内容的数据流。&lt;strong>包含的关键词是contains 后面跟上内容。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102051902.png"
loading="lazy"
alt="image-20230410205121718"
>&lt;/p>
&lt;p>看到这， 基本上对wireshak有了初步了解。&lt;/p>
&lt;h2 id="wireshark抓包分析tcp三次握手">Wireshark抓包分析TCP三次握手
&lt;/h2>&lt;p>（1）TCP三次握手连接建立过程&lt;/p>
&lt;p>Step1：客户端发送一个SYN=1，ACK=0标志的数据包给服务端，请求进行连接，这是第一次握手；&lt;/p>
&lt;p>Step2：服务端收到请求并且允许连接的话，就会发送一个SYN=1，ACK=1标志的数据包给发送端，告诉它，可以通讯了，并且让客户端发送一个确认数据包，这是第二次握手；&lt;/p>
&lt;p>Step3：服务端发送一个SYN=0，ACK=1的数据包给客户端端，告诉它连接已被确认，这就是第三次握手。TCP连接建立，开始通讯。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102051845.png"
loading="lazy"
alt="image-20230410205135665"
>&lt;/p>
&lt;p>（2）wireshark抓包获取访问指定服务端数据包&lt;/p>
&lt;p>Step1：启动wireshark抓包，打开浏览器输入www.huawei.com。&lt;/p>
&lt;p>Step2：使用ping &lt;a class="link" href="https://www.huawei.com" target="_blank" rel="noopener"
>www.huawei.com&lt;/a>获取IP。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102051433.png"
loading="lazy"
alt="image-20230410205150253"
>&lt;/p>
&lt;p>Step3：输入过滤条件获取待分析数据包列表 ip.addr == 211.162.2.183&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102052925.png"
loading="lazy"
alt="image-20230410205200760"
>&lt;/p>
&lt;p>图中可以看到wireshark截获到了三次握手的三个数据包。第四个包才是HTTP的， 这说明HTTP的确是使用TCP建立连接的。&lt;/p>
&lt;p>&lt;strong>第一次握手数据包&lt;/strong>&lt;/p>
&lt;p>客户端发送一个TCP，标志位为SYN，序列号为0， 代表客户端请求建立连接。 如下图。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102052226.png"
loading="lazy"
alt="image-20230410205215079"
>&lt;/p>
&lt;p>数据包的关键属性如下：&lt;/p>
&lt;p>SYN ：标志位，表示请求建立连接&lt;/p>
&lt;p>Seq = 0 ：初始建立连接值为0，数据包的相对序列号从0开始，表示当前还没有发送数据&lt;/p>
&lt;p>Ack =0：初始建立连接值为0，已经收到包的数量，表示当前没有接收到数据&lt;/p>
&lt;p>&lt;strong>第二次握手的数据包&lt;/strong>&lt;/p>
&lt;p>服务器发回确认包, 标志位为 SYN,ACK. 将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即0+1=1, 如下图&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102052307.png"
loading="lazy"
alt="image-20230410205230236"
>&lt;/p>
&lt;p>数据包的关键属性如下：&lt;/p>
&lt;p>[SYN + ACK]: 标志位，同意建立连接，并回送SYN+ACK&lt;/p>
&lt;p>Seq = 0 ：初始建立值为0，表示当前还没有发送数据&lt;/p>
&lt;p>Ack = 1：表示当前端成功接收的数据位数，虽然客户端没有发送任何有效数据，确认号还是被加1，因为包含SYN或FIN标志位。（并不会对有效数据的计数产生影响，因为含有SYN或FIN标志位的包并不携带有效数据）&lt;/p>
&lt;p>&lt;strong>第三次握手的数据包&lt;/strong>&lt;/p>
&lt;p>客户端再次发送确认包(ACK) SYN标志位为0,ACK标志位为1.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1, 如下图:&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102052080.png"
loading="lazy"
alt="image-20230410205245006"
>&lt;/p>
&lt;p>数据包的关键属性如下：&lt;/p>
&lt;p>ACK ：标志位，表示已经收到记录&lt;/p>
&lt;p>Seq = 1 ：表示当前已经发送1个数据&lt;/p>
&lt;p>Ack = 1 : 表示当前端成功接收的数据位数，虽然服务端没有发送任何有效数据，确认号还是被加1，因为包含SYN或FIN标志位（并不会对有效数据的计数产生影响，因为含有SYN或FIN标志位的包并不携带有效数据)。&lt;/p>
&lt;p>就这样通过了TCP三次握手，建立了连接。开始进行数据交互&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102053540.png"
loading="lazy"
alt="image-20230410205305433"
>&lt;/p>
&lt;p>下面针对数据交互过程的数据包进行一些说明：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102053537.png"
loading="lazy"
alt="image-20230410205320467"
>&lt;/p>
&lt;p>数据包的关键属性说明&lt;/p>
&lt;p>Seq: 1&lt;/p>
&lt;p>Ack: 1: 说明现在共收到1字节数据&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102053985.png"
loading="lazy"
alt="image-20230410205335911"
>&lt;/p>
&lt;p>Seq: 1&lt;br>
Ack: 951: 说明现在服务端共收到951字节数据&lt;/p>
&lt;p>在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG。如下&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102053340.png"
loading="lazy"
alt="image-20230410205349152"
>&lt;/p>
&lt;p>其中，对于我们日常的分析有用的就是前面的五个字段。它们的含义是：SYN表示建立连接，FIN表示关闭连接，ACK表示响应，PSH表示有DATA数据传输，RST表示连接重置。&lt;/p>
&lt;h2 id="wireshark分析常用操作">Wireshark分析常用操作
&lt;/h2>&lt;p>调整数据包列表中时间戳显示格式。调整方法为View --&amp;gt;Time Display Format --&amp;gt; Date and Time of Day。调整后格式如下：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/kurisaW/picbed/main/img2023/202304102054848.png"
loading="lazy"
alt="image-20230410205401641"
>&lt;/p></description></item></channel></rss>